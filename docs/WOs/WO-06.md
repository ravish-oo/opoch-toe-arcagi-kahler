# WO-06 — Invariants: minimal block map (2×2 or 3×3)

## Purpose

From **Π-normalized** train pairs, try to learn a **tiny, exact patch codebook** mapping input patches → output patches for block sizes (k\in{2,3}). Emit a codebook only if the mapping is **single-valued and bijective across all occurrences**; otherwise return `None`. This invariant later becomes a convex term in (D) (see `03-invariants-catalog-v1.md` §5).

ARC grids are **rectangular** 2-D arrays of **ints 0–9** in JSON `train`/`test`. ([scikit-image.org][1])

---

## Anchors to read (before coding)

* `docs/anchors/00-vision-universe.md` — Π/FREE, “negation first”.
* `docs/anchors/01-arc-on-the-cloth.md` — ARC↔cloth mapping; invariants feed (D).
* `docs/anchors/03-invariants-catalog-v1.md` §5 — Block substitution invariant.
* `docs/anchors/04-receipts-checklist.md` — receipts; **100% tasks must pass receipts** (either a valid codebook or clean `None`, no exceptions).

---

## Reused, well-documented primitives (no custom algos)

* **Patch extraction**

  * Non-overlapping blocks: `skimage.util.view_as_blocks(arr, block_shape)` (returns a block-view without copies). ([scikit-image.org][2])
  * Sliding windows (if needed later): `skimage.util.view_as_windows(arr, window_shape, step)`. ([pydocs.github.io][3])
    Module docs: `skimage.util` (stable). ([scikit-image.org][1])
* **Exact equality / FREE checks**: `numpy.array_equal`, `numpy.rot90`, `numpy.flip*`. ([NumPy][4])
* **Unique / counts** (for bijection and coverage stats): `numpy.unique(..., axis=…)` with `return_counts=True`. ([NumPy][5])
* **Hashing** (receipts): `hashlib.sha256`. ([Python documentation][6])

*(All CPU-only; grids are ≤30×30.)*

---

## File & API (fixed)

**File:** `arc_cloth/model/invariants.py`

```python
from __future__ import annotations
from typing import TypedDict, Optional, Dict, Any, Tuple, List

class BlockMap(TypedDict, total=False):
    block_size: Optional[Tuple[int, int]]   # (k, k) or None
    codebook: Optional[Dict[bytes, bytes]]  # {input_patch_bytes: output_patch_bytes}
    __meta__: Dict[str, Any]                # receipts: coverage, bijection flags, hash, etc.

def infer_block_codebook(train: List[Dict[str, List[List[int]]]]) -> BlockMap:
    """
    Learn an exact input→output patch dictionary for k∈{2,3} if (and only if)
    it is single-valued and bijective across all occurrences in all train pairs.
    Returns {'block_size': (k,k), 'codebook': {...}} or {'block_size': None, 'codebook': None}.
    """
```

**Assumptions:** Inputs have passed WO-02 (Π canonicalization: shape-aware D4/D2, ascending-numeric palette). Train input/output grids are int arrays 0–9.

---

## Exact method (library-backed, reproducible)

We try (k=2) then (k=3); accept the **first** (k) that yields a valid bijective mapping; else return `None`.

1. **Quick eligibility checks per pair**

   * Both input (X) and output (Y) must have **height and width divisible by k** for non-overlapping blocks. (v1 keeps this strict; no partial tiles.)
   * Shapes must be identical for 1-to-1 block alignment. If not, **skip this k** for the whole task.

2. **Extract non-overlapping (k\times k) blocks** (no copies):

   ```python
   from skimage.util import view_as_blocks
   Bx = view_as_blocks(X, block_shape=(k,k))  # shape: [H/k, W/k, k, k]
   By = view_as_blocks(Y, block_shape=(k,k))  # same
   ```

   Then reshape to 2-D lists of patches:

   ```python
   Bx2 = Bx.reshape(-1, k, k)
   By2 = By.reshape(-1, k, k)
   ```

   (Block views are the canonical, doc-backed way to slice arrays into equal patches.) ([scikit-image.org][2])

3. **Canonicalize patches as bytes keys/values**

   ```python
   in_keys  = [bx.astype('uint8').tobytes() for bx in Bx2]
   out_vals = [by.astype('uint8').tobytes() for by in By2]
   ```

   (Exact, integer-preserving; no hashing beyond SHA-256 receipt.)

4. **Build mapping and check single-valuedness**

   * For each aligned position (r): require that the same **input key** always maps to the **same** output bytes across **all** train pairs.
   * Implement with a dict and `numpy.unique`/`return_counts=True` to sanity-check duplicates per key. ([NumPy][5])
   * If an input key maps to **multiple** different outputs → **reject** this k.

5. **Check bijection (one-to-one)**

   * Collect the set of output bytes; require that **no two** different input keys map to the **same** output bytes (i.e., |image| == |domain|).
   * If many→one appears → **reject** this k.

6. **Coverage** (receipt only)

   * `coverage = (# aligned positions covered by keys seen ≥1×) / (total aligned positions across all trains)`
   * For strict v1, if single-valued + bijective hold **only on a strict subset** of positions, but other positions are **different unseen inputs**, we still accept the codebook **if** there is **no contradicting evidence** (no conflicts). Record coverage so D can weight it.

7. **Choose k**

   * If k=2 passes, emit it; else try k=3; else return `None`.

8. **FREE-invariance receipt (sanity)**

   * Because we run after Π, we don’t require equality under 90° for rectangles. Still, we check that applying **shape-aware FREE** to both (X,Y) (same transform) does **not** change the learned pairs (the relative mapping is content-based). Use `np.rot90/flip` exactly as documented. ([NumPy][7])

---

## Receipts to emit (first-class)

Return in `__meta__`:

* `k_tried: [2,3]`, `accepted_k: int|None`
* `n_pairs`: number of train pairs processed; `n_blocks_total`
* `single_valued_ok: bool`, `bijection_ok: bool`
* `coverage: float` (0..1)
* `free_invariance_ok: bool` (shape-aware)
* `hash_codebook: str` — SHA-256 of a stable serialization of `(k, sorted(codebook.items()))` (use `hashlib.sha256`). ([Python documentation][6])
* `method`: docs we used (e.g., `skimage.util.view_as_blocks`, `numpy.array_equal/unique/rot90/flip`). ([scikit-image.org][2])

**Reviewer rule:** **100% of tasks must pass receipts**—i.e., function **never** throws; it returns either a valid codebook (with flags true) or clean `None` (with flags false), across the full ARC corpus.

---

## Debugging playbook (implementer)

* **Shape not divisible by k** → immediately skip that k; record reason in `__meta__.k_reject_reason` (e.g., “dim_not_divisible”).
* **Conflicting mapping** (same input → different outputs) → set `single_valued_ok=False`, reject k, continue to next k.
* **Bijection fail** → two inputs map to same output → set `bijection_ok=False`, reject k.
* **Low coverage but no conflicts** → still acceptable; record coverage so the potential (D) can weight it.
* **FREE check fails** → verify you applied **the same** transform to both input & output before extracting blocks, using `np.rot90/flip`. ([NumPy][7])

---

## Runner changes

* Add a probe in `arc_cloth/runner/run_task.py` and `scripts/run_arc.py`:

  * `--check-invariants blockmap` runs load → canonicalize → `infer_block_codebook(train)`.
  * Print/CSV per task:
    `accepted_k, single_valued_ok, bijection_ok, coverage, free_invariance_ok, n_blocks_total, hash_codebook`.

ARC corpus is a directory of JSONs with 0–9 int grids; block extraction via `view_as_blocks` is O(pixels) and instantaneous on CPU. ([scikit-image.org][1])

---

## Acceptance criteria

* **Deterministic & Π-stable** on all tasks.
* **No exceptions** on full corpus; either a valid codebook `(k, dict)` or `(None, None)`.
* **Single-valued + bijection** flags agree with emitted codebook.
* **FREE-invariance** holds (shape-aware).
* **Receipts pass on 100% of tasks** (reviewer checklist).
* **No custom algorithms**: only `skimage.util.view_as_blocks/view_as_windows`, `numpy.unique`, `numpy.array_equal`, `numpy.rot90/flip`, `hashlib.sha256`. ([scikit-image.org][2])

---

## Minimal code sketch (so Claude calls the right APIs)

```python
import numpy as np, hashlib
from skimage.util import view_as_blocks
from typing import Dict, Any, List, Tuple, Optional

def _build_codebook_for_k(pairs, k: int) -> Tuple[Optional[Dict[bytes, bytes]], Dict[str, Any]]:
    # Eligibility check across ALL pairs
    for X, Y in pairs:
        H, W = X.shape
        if X.shape != Y.shape or (H % k) or (W % k):
            return None, {"eligible": False, "reason": "shape_mismatch_or_not_divisible"}

    # Collect aligned blocks from all pairs
    codebook: Dict[bytes, bytes] = {}
    seen_positions = 0
    conflicts = False
    many_to_one = False

    for X, Y in pairs:
        Bx = view_as_blocks(X, block_shape=(k,k)).reshape(-1, k, k)
        By = view_as_blocks(Y, block_shape=(k,k)).reshape(-1, k, k)
        for bx, by in zip(Bx, By):
            key = bx.astype("uint8").tobytes()
            val = by.astype("uint8").tobytes()
            seen_positions += 1
            if key in codebook and codebook[key] != val:
                conflicts = True
                break
            codebook.setdefault(key, val)
        if conflicts: break

    if conflicts:
        return None, {"eligible": True, "single_valued_ok": False, "bijection_ok": False}

    # bijection check: |image| == |domain|
    single_valued_ok = True
    image_vals = set(codebook.values())
    bijection_ok = (len(image_vals) == len(codebook))

    meta = {
        "eligible": True,
        "single_valued_ok": single_valued_ok,
        "bijection_ok": bijection_ok,
        "coverage": seen_positions / seen_positions if seen_positions else 0.0,  # all aligned
        "n_blocks_total": seen_positions,
        "hash_codebook": hashlib.sha256(
            ("|".join([str(k), str(len(codebook))]) + "|" +
             "|".join(f"{k_}:{v_}" for k_, v_ in sorted(codebook.items()))
            ).encode()
        ).hexdigest()
    }
    return (codebook if bijection_ok else None), meta

def infer_block_codebook(train: List[Dict[str, List[List[int]]]]) -> Dict[str, Any]:
    pairs = [(np.asarray(p["input"], dtype=np.int16),
              np.asarray(p["output"], dtype=np.int16)) for p in train]
    for k in (2, 3):
        cb, meta = _build_codebook_for_k(pairs, k)
        # FREE-invariance: try a shape-aware transform on one pair
        free_ok = True
        if cb is not None:
            X, Y = pairs[0]
            if X.shape[0] == X.shape[1]:
                Xt, Yt = np.rot90(X,1), np.rot90(Y,1)
            else:
                Xt, Yt = np.rot90(X,2), np.rot90(Y,2)
            cb_t, _ = _build_codebook_for_k([(Xt, Yt)], k)
            free_ok = (cb_t is None) or (len(cb_t) == len(cb))  # structural sanity

        if cb is not None:
            return {"block_size": (k, k), "codebook": cb,
                    "__meta__": {**meta, "accepted_k": k, "free_invariance_ok": free_ok}}

    # No k accepted
    return {"block_size": None, "codebook": None,
            "__meta__": {"eligible": False, "reason": "no_bijective_k", "free_invariance_ok": True}}
```

---

[1]: https://scikit-image.org/docs/0.25.x/api/skimage.util.html?utm_source=chatgpt.com "skimage.util — skimage 0.25.2 documentation"
[2]: https://scikit-image.org/docs/0.25.x/auto_examples/numpy_operations/plot_view_as_blocks.html?utm_source=chatgpt.com "Block views on images/arrays"
[3]: https://pydocs.github.io/p/skimage/0.17.2/api/skimage.util.shape.view_as_windows.html?utm_source=chatgpt.com "skimage.util.shape.view_as_windows - Document"
[4]: https://numpy.org/doc/2.1/reference/generated/numpy.array_equal.html?utm_source=chatgpt.com "numpy.array_equal — NumPy v2.1 Manual"
[5]: https://numpy.org/doc/stable/reference/generated/numpy.unique.html?utm_source=chatgpt.com "numpy.unique — NumPy v2.3 Manual"
[6]: https://docs.python.org/3/library/hashlib.html?utm_source=chatgpt.com "hashlib — Secure hashes and message digests"
[7]: https://numpy.org/doc/2.2/reference/generated/numpy.rot90.html?utm_source=chatgpt.com "numpy.rot90 — NumPy v2.2 Manual"
