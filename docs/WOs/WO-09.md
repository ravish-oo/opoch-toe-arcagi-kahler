# WO-09 — Convex solve (CVXPY one-shot)

## Purpose

Given a DCP-valid program from WO-08, **solve once** to get the soft solution (X_{\text{prob}}\in[0,1]^{H\times W\times C}) that satisfies the simplex and Γ equalities, with solver receipts (status, duality gap, residuals). CVXPY handles the modeling and solver call; we do **no** algorithmic work. CVXPY is a Python-embedded modeling language with DCP checks and shipped solvers (CLARABEL, OSQP, SCS) ([CVXPY][1]).

## Anchors

* `00-vision-universe.md` — paid move = convex descent; GLUE via Γ.
* `01-arc-on-the-cloth.md` — Z = product of simplexes; Γ = linear equalities.
* `03-invariants-catalog-v1.md` — which terms may appear in (D).
* `04-receipts-checklist.md` — DCP, duality gap, equality residuals.

---

## Reused libraries (no custom math)

* **CVXPY** Problem/solve/DCP check/solver stats: `Problem`, `.solve()`, `.is_dcp()`, `solver_stats`, `status` ([CVXPY][2])
* **Solvers** (shipped): **CLARABEL**, **OSQP**, **SCS**; choose per problem class (LP/QP/SOCP) ([CVXPY][3]). (OSQP has CVXPY parser docs) ([osqp.org][4])
* **CVXPY reshape**: explicit order parameter; default is Fortran/column-major (documented) — we pass `order='C'` to match NumPy row-major vec convention for (A\cdot\mathrm{vec}(X)) ([CVXPY][5])
* **SciPy sparse** for Γ residuals: CSR/COO; CSR sums duplicates by design; `csr_matrix.sum_duplicates()` exists (in-place) ([CVXPY][6])

---

## File & API (fixed)

**File:** `arc_cloth/solvers/convex_one_shot.py`

```python
from __future__ import annotations
from typing import TypedDict, List, Dict, Any
import cvxpy as cp
import numpy as np
import scipy.sparse as sp

class SolveReceipts(TypedDict):
    status: str
    optimal_value: float | None
    duality_gap: float | None
    eq_residual_max: float
    simplex_residual_max: float
    solver_name: str
    solve_time_s: float

def solve_convex(H: int, W: int, C: int,
                 prog: Dict[str, Any],
                 solver: str = "CLARABEL",
                 eps_eq: float = 1e-7) -> tuple[np.ndarray, SolveReceipts]:
    """
    Solve the CVXPY program once and return (X_prob, receipts).
    X_prob has shape (H,W,C), entries in [0,1], per-pixel sums ~ 1.
    """
```

---

## Exact steps (gluing only)

1. **Extract program pieces** from WO-08:

```python
X: cp.Variable = prog["X"]
objective: cp.Expression = prog["objective"]
constraints: list[cp.Constraint] = prog["constraints"]
prob = cp.Problem(cp.Minimize(objective), constraints)
```

2. **DCP guard** (fail fast if modeling bug):

```python
assert prob.is_dcp(), "Program is not DCP (see CVXPY DCP rules)"
```

(DCP tutorial/guard is documented) ([CVXPY][7])

3. **Choose solver** (no guessing):

* Default **CLARABEL** (handles LP/QP/SOCP/EXP/POW; shipped) ([CVXPY][3]).
* Fallback **OSQP** for pure QP/box-QP cases; **SCS** for cones.
* Pass solver by name and a sensible tolerance/time-limit.

```python
solve_kwargs = dict(verbose=False, warm_start=True)
if solver.upper() == "OSQP":
    solve_kwargs["solver"] = cp.OSQP
elif solver.upper() == "SCS":
    solve_kwargs["solver"] = cp.SCS
else:
    solve_kwargs["solver"] = cp.CLARABEL
result = prob.solve(**solve_kwargs)  # CVXPY orchestrates solve :contentReference[oaicite:8]{index=8}
```

4. **Read receipts** (status, gap, time):

```python
status = prob.status                    # e.g., OPTIMAL / OPTIMAL_INACCURATE / INFEASIBLE
stats = prob.solver_stats               # has .solve_time, sometimes .num_iters, depending solver
gap = getattr(stats, "duality_gap", None)  # Some solvers expose it, others not
val = prob.value
```

(Problem/solve/status/stats documented) ([CVXPY][2])

5. **Pull solution & clamp numerics**

```python
X_prob = np.asarray(X.value, dtype=float)  # shape (H,W,C)
X_prob = np.clip(X_prob, 0.0, 1.0)
simplex_sum = X_prob.sum(axis=2, keepdims=True)
```

6. **Compute residuals (post-solve receipts)**

* **Simplex residual**: `max| sum_c X[i,j,c] − 1 |`
* **Γ residual**: If Γ exists, vectorize in **row-major** and check `||A@vec(X)||_∞`

```python
simplex_resid = np.max(np.abs(simplex_sum.squeeze(-1) - 1.0))

A = prog.get("A_gamma")  # optional, CSR
if isinstance(A, sp.csr_matrix):
    X_vec = X_prob.reshape(H*W*C, order="C")  # explicit C-order vs CVXPY’s default F-order :contentReference[oaicite:10]{index=10}
    eq_resid = np.max(np.abs(A @ X_vec))
else:
    eq_resid = 0.0
```

7. **Assemble receipts** and **return** `(X_prob, receipts)`:

```python
receipts: SolveReceipts = {
  "status": status,
  "optimal_value": float(val) if val is not None else None,
  "duality_gap": float(gap) if gap is not None else None,
  "eq_residual_max": float(eq_resid),
  "simplex_residual_max": float(simplex_resid),
  "solver_name": solve_kwargs["solver"].__name__ if hasattr(solve_kwargs["solver"], "__name__") else str(solve_kwargs["solver"]),
  "solve_time_s": float(getattr(stats, "solve_time", np.nan)),
}
```

---

## Receipts to **verify**

* `prob.is_dcp() == True` (construction sanity) ([CVXPY][7])
* `status` is **OPTIMAL** (or **OPTIMAL_INACCURATE** with small residuals); infeasible/unbounded should surface immediately. (Problem class/solve behavior) ([CVXPY][2])
* `duality_gap` (when solver exposes it) small; otherwise `None` is fine (OSQP often reports KKT residuals instead; use residuals below) ([osqp.org][4])
* `eq_residual_max` ≤ tol (e.g., 1e-6)
* `simplex_residual_max` ≤ tol (e.g., 1e-6)

---

## Debugging playbook

* **Not DCP**: print `objective`/term names; compare against allowed atoms (sum, norm1, sum_squares, tv, reshape). CVXPY DCP tutorial/atom tables show what’s allowed ([CVXPY][7]).
* **Vectorization mismatch** (residual not ~0 despite OPTIMAL): ensure `reshape(..., order='C')` in both WO-08 and WO-09; CVXPY defaults to Fortran order unless order is set (doc shows column-major) ([CVXPY][5]).
* **Large eq residuals**: A may have duplicate rows; ensure Γ assembly used COO→CSR (duplicates are **summed** as SciPy docs state) and/or call `csr.sum_duplicates()` ([docs.scipy.org][8]).
* **Solver choice**: if CLARABEL reports INFEASIBLE but OSQP/ SCS succeed, rerun heuristically with OSQP for QP, SCS for general cones (CVXPY solver features page) ([CVXPY][3]).

---

## Runner wiring (real ARC corpus)

* **`run_task.py`**: add a `"--mode convex"` path that:

  * builds program via WO-08, calls `solve_convex`, then **calls WO-10 snap** to write an intermediate PNG/JSON for inspection.
  * prints receipts: `status, gap, eq_resid_max, simplex_resid_max, time_s`.
* **`scripts/run_arc.py`**: batch over all tasks:

  * CSV fields: `task, status, duality_gap, eq_resid_max, simplex_resid_max, solve_time_s, solver`.

ARC tasks are JSON with tiny 0–9 int grids (1×1..30×30), so CPU solves are fast. CVXPY shims solvers and unpacks results for us ([CVXPY][1]).

---

## Acceptance criteria

* **Optimal status** on solvable tasks; residuals ≤ tol.
* **Returns** `X_prob` with entries ∈[0,1] and per-pixel sums ~ 1.
* **Receipts** present (status, gap/time if available, both residuals).
* **Corpus-wide** runner: 100% tasks produce receipts (no exceptions); unsatisfied tasks show non-optimal status rather than crashes.

---

## Minimal code skeleton (Claude fills, using only cited APIs)

```python
import cvxpy as cp, numpy as np, scipy.sparse as sp

def solve_convex(H,W,C, prog, solver="CLARABEL", eps_eq=1e-7):
    X, objective, constraints = prog["X"], prog["objective"], prog["constraints"]
    prob = cp.Problem(cp.Minimize(objective), constraints)
    assert prob.is_dcp(), "Not DCP per CVXPY rules"  # :contentReference[oaicite:19]{index=19}

    kwargs = dict(verbose=False, warm_start=True)
    kwargs["solver"] = {"CLARABEL": cp.CLARABEL, "OSQP": cp.OSQP, "SCS": cp.SCS}.get(solver.upper(), cp.CLARABEL)
    prob.solve(**kwargs)  # CVXPY orchestrates solver call :contentReference[oaicite:20]{index=20}

    X_prob = np.clip(np.asarray(X.value, float), 0.0, 1.0)
    simplex_resid = float(np.max(np.abs(X_prob.sum(axis=2) - 1.0)))

    A = prog.get("A_gamma", None)
    if isinstance(A, sp.csr_matrix):
        X_vec = X_prob.reshape(H*W*C, order="C")  # be explicit; cvxpy reshape defaults differ :contentReference[oaicite:21]{index=21}
        eq_resid = float(np.max(np.abs(A @ X_vec)))
    else:
        eq_resid = 0.0

    stats = prob.solver_stats
    gap = getattr(stats, "duality_gap", None)
    receipts = {
        "status": prob.status,
        "optimal_value": float(prob.value) if prob.value is not None else None,
        "duality_gap": float(gap) if gap is not None else None,
        "eq_residual_max": eq_resid,
        "simplex_residual_max": simplex_resid,
        "solver_name": kwargs["solver"].__name__ if hasattr(kwargs["solver"],"__name__") else str(kwargs["solver"]),
        "solve_time_s": float(getattr(stats, "solve_time", np.nan)),
    }
    return X_prob, receipts
```

**Docs relied on:** DCP rules/atoms; `reshape` order; shipped solvers (CLARABEL/OSQP/SCS); Problem/solve/stats; SciPy sparse COO→CSR behavior. ([CVXPY][7])

---

[1]: https://www.cvxpy.org/version/1.4/tutorial/intro/index.html?utm_source=chatgpt.com "What is CVXPY? — CVXPY 1.4 documentation"
[2]: https://www.cvxpy.org/version/1.1/api_reference/cvxpy.problems.html?utm_source=chatgpt.com "Problems — CVXPY 1.1.24 documentation"
[3]: https://www.cvxpy.org/tutorial/solvers/index.html?utm_source=chatgpt.com "Solver Features -"
[4]: https://osqp.org/docs/parsers/cvxpy.html?utm_source=chatgpt.com "CVXPY — OSQP documentation"
[5]: https://www.cvxpy.org/_modules/cvxpy/atoms/affine/reshape.html?utm_source=chatgpt.com "cvxpy.atoms.affine.reshape -"
[6]: https://www.cvxpy.org/tutorial/intro/index.html?utm_source=chatgpt.com "What is CVXPY? -"
[7]: https://www.cvxpy.org/tutorial/dcp/index.html?utm_source=chatgpt.com "Disciplined Convex Programming - - cvxpy"
[8]: https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.sum_duplicates.html?utm_source=chatgpt.com "sum_duplicates — SciPy v1.16.2 Manual"
