# WO-05 — Invariants: mirror / concat flags

## Purpose

From **Π-normalized** train outputs, detect:

1. **Exact mirror seams** (horizontal and/or vertical), and
2. **Exact band concatenations** (left|right or top|bottom halves equal),

in a way that is FREE-invariant and deterministic. ARC tasks are JSON with `train` pairs and a `test` input; grids are rectangular 2-D arrays of ints 0–9. ([GitHub][1])

## Anchors to read (before coding)

* `docs/anchors/00-vision-universe.md` — Π/FREE and “negation first”.
* `docs/anchors/01-arc-on-the-cloth.md` — ARC↔cloth map; FREE=D4/D2; invariants feed D (§3).
* `docs/anchors/03-invariants-catalog-v1.md` §3–4 — Mirror & Concatenation invariants.
* `docs/anchors/04-receipts-checklist.md` — FREE-invariance receipts and “all tasks pass receipts” rule.

---

## Reused, well-documented primitives (no custom algos)

* **NumPy array isometries** (exact, integer-preserving):

  * `np.flip`, `np.flipud`, `np.fliplr` for vertical/horizontal flips. ([NumPy][2])
  * `np.roll` if you optionally test shifted bands (we’ll keep that out of v1 to stay exact). ([NumPy][3])
* **NumPy equality & joining**:

  * `np.array_equal` for strict equality checks. ([NumPy][4])
  * `np.concatenate` if you need to reconstruct/check a concat form. ([NumPy][5])
* *(Optional helpers for patch/block reasoning in future WOs: `skimage.util.view_as_blocks` to slice grids cleanly. Not required in v1.)* ([scikit-image.org][6])

These are stable, widely used, and exactly match our needs.

---

## File & API (fixed)

**File:** `arc_cloth/model/invariants.py`

```python
from __future__ import annotations
from typing import TypedDict, List, Dict, Any, Literal
import numpy as np

class Symmetries(TypedDict, total=False):
    mirror_h: bool                 # mirror across a vertical seam (left↔right)
    mirror_v: bool                 # mirror across a horizontal seam (top↔bottom)
    mirror_h_seams: List[int]      # column seams j where G[:, :j] == fliplr(G[:, j:])
    mirror_v_seams: List[int]      # row seams i where G[:i, :] == flipud(G[i:, :])
    concat_axes: List[Literal["h","v"]]  # exact band concatenations detected in outputs
    __meta__: Dict[str, Any]       # receipts (per-grid evidence, D4/D2 invariance, hashes)

def infer_symmetries(train: List[Dict[str, List[List[int]]]]) -> Symmetries:
    """
    Detect exact mirror seams and band concats from Π-normalized train outputs.

    Requirements:
      - Deterministic.
      - Mirror: verify equality across at least one seam for every train output.
      - Concat: detect exact left|right or top|bottom equality in outputs.
      - FREE invariance respected (shape-aware: D4 for squares, D2 for rectangles).
    """
```

**Assumptions:** WO-02 has already produced Π-normalized grids with shape-aware pose (squares→D4; rectangles→D2) and palette remap to contiguous `[0..C-1]`. ARC grids remain rectangular int arrays 0–9. ([GitHub][1])

---

## Detection method (library-backed, exact)

Let each Π-normalized train **output** be `G` with shape `(H, W)`.

### A) Mirror seams (exact equality across a seam)

We check all admissible seam positions:

* **Horizontal mirror (left|right) around a vertical seam at column `j`**
  Condition: left half equals reflection of right half:

  ```
  left  = G[:, :j]
  right = G[:, j:]
  # To mirror at the seam, widths must match
  if left.shape[1] == right.shape[1]:
      mirror_ok = np.array_equal(left, np.fliplr(right))  # exact compare
  ```

  If `mirror_ok`, record `j` in `mirror_h_seams`.

* **Vertical mirror (top|bottom) around a horizontal seam at row `i`**
  Same idea with rows and `np.flipud`:

  ```
  top = G[:i, :]
  bot = G[i:, :]
  if top.shape[0] == bot.shape[0]:
      mirror_ok = np.array_equal(top, np.flipud(bot))
  ```

  Record `i` in `mirror_v_seams`.

Because `np.fliplr/flipud` are documented exact views, these checks are O(1) to create the view + O(#pixels) to compare. ([NumPy][7])

**Task-level mirror flags**:

* `mirror_h = True` **iff** every train output has **at least one** `mirror_h_seam`.
* `mirror_v = True` **iff** every train output has **at least one** `mirror_v_seam`.

This satisfies “verifies equality across seam on outputs” at the *task* level.

### B) Band concatenation (exact halves equal)

* **Horizontal concat** (`"h"`): `G[:, :W//2] == G[:, W - W//2:]` **and** widths match (handles odd W by taking the larger/right half appropriately—we choose v1 to require *exact* half split, i.e., W even).
  `np.array_equal(G[:, :k], G[:, k:])` with `k = W//2` and `2*k == W`.
* **Vertical concat** (`"v"`): `G[:H//2, :] == G[H - H//2:, :]` and `2*(H//2) == H`.

**Task-level concat flag**: include `"h"` in `concat_axes` iff **every** train output meets the horizontal condition; include `"v"` similarly.

*(We keep v1 strict and simple: equal halves. Shifted/tiled bands belong to the “tiling” invariant (WO-04) or later patch; no rolling in v1.)*
If later needed, `np.roll` can check shifted equality under a known period from WO-04. ([NumPy][3])

---

## FREE-invariance receipts (shape-aware)

* For any **square** output, rotate by 90° and re-detect:
  Mirror_H on `G` should map to Mirror_V on `rot90(G)`; same for concat axis.
  Use `np.rot90` and rerun the same checks. ([NumPy][8])
* For **rectangles**, verify invariance under 180° and axis flips (D2) with **no axis swap**:
  Apply `np.rot90(G, 2)`, `np.flipud`, `np.fliplr` and confirm the existence of seams/concats is preserved.

---

## Receipts to emit (first-class)

Attach to `__meta__`:

* `per_grid`: list of dicts per output:

  ```
  { "shape":[H,W],
    "mirror_h_seams":[...],
    "mirror_v_seams":[...],
    "concat_h": bool,
    "concat_v": bool,
    "group": "D4"|"D2" }
  ```
* `mirror_h`: bool, `mirror_v`: bool, `concat_axes`: ["h","v"] subset
* `free_invariance_ok`: overall bool after the shape-aware checks above
* `hash_sym`: SHA-256 of a canonical serialization of
  `(mirror_h, mirror_v, sorted(mirror_h_seams_all), sorted(mirror_v_seams_all), concat_axes)`
* `method`: record the doc-backed primitives used:

  * flips: `numpy.fliplr/flipud/flip` ([NumPy][7])
  * equality: `numpy.array_equal` ([NumPy][4])
  * rotation: `numpy.rot90` (for D4 checks on squares) ([NumPy][8])

Reviewer must confirm **100% of tasks pass receipts** (no exceptions; when no mirror/concat exists, flags are simply `False` and seams lists empty).

---

## Debugging playbook (implementer)

* **No seams detected but expected**: print a small diff on `left` vs `fliplr(right)` for the failing output; confirm W even for concat, or relax via tiling invariant (different WO).
* **Square FREE check fails**: verify you ran rotation on the same grid and compared the *swapped* axes expectations (H↔V).
* **Rectangle FREE**: ensure you tested only D2 (180° + flips), not 90°.

---

## Runner changes

* In `arc_cloth/runner/run_task.py`, add probe `"--check-invariants symmetries"`:

  * load → canonicalize → `infer_symmetries(train)` → print:
    `mirror_h, mirror_v, concat_axes, free_invariance_ok, seams-histogram`
* In `scripts/run_arc.py`, add batch flag:

  * `--check-invariants symmetries` writes CSV:
    `task_path,mirror_h,mirror_v,concat_axes,free_invariance_ok,n_outputs,n_square,n_rect,n_h_seams,n_v_seams,hash_sym`.

ARC’s JSON/0–9 rectangular format makes this trivial on CPU. ([GitHub][1])

---

## Acceptance criteria

* **Deterministic & Π-stable** on all tasks.
* **FREE-invariance** holds (shape-aware).
* **Receipts pass on 100% of tasks** (no exceptions; flags/seams set appropriately).
* **No custom algorithms** beyond the cited NumPy primitives.
* **Ready for D**: these flags and seams will directly enable mirror/concat terms in the convex potential (WO-08) as exact equalities (Γ) or penalties, per `03-invariants-catalog-v1.md`.

---

## Minimal code sketch (so Claude calls the right APIs)

```python
import numpy as np, hashlib
from typing import List, Dict, Any

def _mirror_h_seams(G: np.ndarray) -> List[int]:
    H, W = G.shape
    seams = []
    for j in range(1, W):  # seam between j-1 and j
        L, R = G[:, :j], G[:, j:]
        if L.shape[1] == R.shape[1] and np.array_equal(L, np.fliplr(R)):
            seams.append(j)
    return seams

def _mirror_v_seams(G: np.ndarray) -> List[int]:
    H, W = G.shape
    seams = []
    for i in range(1, H):
        T, B = G[:i, :], G[i:, :]
        if T.shape[0] == B.shape[0] and np.array_equal(T, np.flipud(B)):
            seams.append(i)
    return seams

def _concat_h(G: np.ndarray) -> bool:
    H, W = G.shape
    if W % 2: return False
    return np.array_equal(G[:, :W//2], G[:, W//2:])

def _concat_v(G: np.ndarray) -> bool:
    H, W = G.shape
    if H % 2: return False
    return np.array_equal(G[:H//2, :], G[H//2:, :])

def infer_symmetries(train: List[Dict[str, List[List[int]]]]) -> Dict[str, Any]:
    outs = [np.asarray(p["output"], dtype=np.int16) for p in train]
    per = []; n_sq=n_rect=0
    all_h, all_v = True, True
    all_ch, all_cv = True, True
    all_h_seams=[], all_v_seams=[]
    for G in outs:
        H, W = G.shape
        tag = "D4" if H==W else "D2"
        n_sq += (tag=="D4"); n_rect += (tag=="D2")
        hs = _mirror_h_seams(G); vs = _mirror_v_seams(G)
        ch = _concat_h(G); cv = _concat_v(G)
        all_h &= bool(hs); all_v &= bool(vs)
        all_ch &= ch; all_cv &= cv
        all_h_seams.extend(hs); all_v_seams.extend(vs)
        per.append({"shape":[H,W], "group":tag,
                    "mirror_h_seams":hs, "mirror_v_seams":vs,
                    "concat_h":ch, "concat_v":cv})

    mirror_h = bool(all_h)
    mirror_v = bool(all_v)
    concat_axes = []
    if all_ch: concat_axes.append("h")
    if all_cv: concat_axes.append("v")

    # FREE invariance (shape-aware)
    free_ok = True
    for G in outs:
        H, W = G.shape
        if H==W:
            G90 = np.rot90(G,1)
            # mirror H on G ↔ mirror V on G90; concat h ↔ concat v
            if mirror_h and not _mirror_v_seams(G90): free_ok=False; break
            if mirror_v and not _mirror_h_seams(G90): free_ok=False; break
            if ("h" in concat_axes) and not _concat_v(G90): free_ok=False; break
            if ("v" in concat_axes) and not _concat_h(G90): free_ok=False; break
            break
        else:
            G2 = np.rot90(G,2)
            if bool(_mirror_h_seams(G)) != bool(_mirror_h_seams(G2)): free_ok=False; break
            if bool(_mirror_v_seams(G)) != bool(_mirror_v_seams(G2)): free_ok=False; break
            if _concat_h(G) != _concat_h(G2): free_ok=False; break
            if _concat_v(G) != _concat_v(G2): free_ok=False; break

    meta = {
      "per_grid": per,
      "free_invariance_ok": free_ok,
      "n_outputs": len(outs), "n_square": int(n_sq), "n_rect": int(n_rect),
      "hash_sym": hashlib.sha256(
          ("|".join([str(mirror_h),str(mirror_v),",".join(concat_axes),
                     str(sorted(all_h_seams)), str(sorted(all_v_seams))]).encode())
      ).hexdigest(),
      "method": {"flipud": "numpy.flipud", "fliplr": "numpy.fliplr",
                 "array_equal":"numpy.array_equal", "rot90":"numpy.rot90"}
    }
    return {"mirror_h": mirror_h, "mirror_v": mirror_v,
            "mirror_h_seams": sorted(all_h_seams),
            "mirror_v_seams": sorted(all_v_seams),
            "concat_axes": concat_axes, "__meta__": meta}
```

*Doc sources for the primitives used:* `np.flip/flipud/fliplr` (exact axis flips) ([NumPy][2]), `np.array_equal` (strict equality) ([NumPy][4]), `np.concatenate` if needed ([NumPy][5]), ARC JSON structure for context ([GitHub][1]).

---

[1]: https://github.com/fchollet/ARC-AGI?utm_source=chatgpt.com "fchollet/ARC-AGI: The Abstraction and Reasoning Corpus"
[2]: https://numpy.org/devdocs/reference/generated/numpy.flip.html?utm_source=chatgpt.com "numpy.flip — NumPy v2.4.dev0 Manual"
[3]: https://numpy.org/doc/2.2/reference/generated/numpy.roll.html?utm_source=chatgpt.com "numpy.roll — NumPy v2.2 Manual"
[4]: https://numpy.org/doc/2.1/reference/generated/numpy.array_equal.html?utm_source=chatgpt.com "numpy.array_equal — NumPy v2.1 Manual"
[5]: https://numpy.org/doc/stable/reference/generated/numpy.concatenate.html?utm_source=chatgpt.com "numpy.concatenate — NumPy v2.3 Manual"
[6]: https://scikit-image.org/docs/0.25.x/auto_examples/numpy_operations/plot_view_as_blocks.html?utm_source=chatgpt.com "Block views on images/arrays"
[7]: https://numpy.org/doc/2.1/reference/generated/numpy.fliplr.html?utm_source=chatgpt.com "numpy.fliplr — NumPy v2.1 Manual"
[8]: https://numpy.org/doc/2.2/reference/generated/numpy.flipud.html?utm_source=chatgpt.com "numpy.flipud — NumPy v2.2 Manual"
