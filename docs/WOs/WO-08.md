# WO-08 — D builder (CVXPY backend)

## Purpose

Compose the **single convex objective (D)** and hard constraints for one candidate test size ((H^*,W^*)), using only DCP-valid CVXPY atoms. Output a program object the solver can run in WO-09.

ARC grids are tiny rectangular matrices with entries 0–9; our decision tensor is (X\in[0,1]^{H^*\times W^*\times C}) with per-cell simplex constraints (\sum_c X_{ijc}=1).

---

## Anchors to read

* `00-vision-universe.md` — paid move = convex descent; GLUE = Γ equalities.
* `01-arc-on-the-cloth.md` — Z (product of simplexes), Γ (linear equalities).
* `03-invariants-catalog-v1.md` — the only v1 terms allowed (color counts, periods, mirror/concat, block-substitution, optional TV line term).
* `04-receipts-checklist.md` — DCP checks, solver status, duality gap, train reproduction.

---

## Reused, well-documented primitives (no custom math)

* **CVXPY core** (DCP rules & atoms)

  * DCP tutorial & rules. ([Cvxpy][1])
  * Atom tables (“Atomic Functions”). ([Cvxpy][2])
  * `total_variation` atom (optional line/border term). ([Cvxpy][3])
  * `reshape` behavior (column-major by default; we’ll avoid surprises and keep things 2-D/3-D where possible). ([Cvxpy][4])
  * Solver page (CLARABEL/OSQP/SCS shipped by default; ECOS deprecation note). Use CLARABEL or OSQP by default. ([Cvxpy][5])
* **SciPy sparse** (if Γ comes in as a sparse CSR): `coo_matrix` (construct), `csr_matrix` (final). COO→CSR sums duplicates by design. ([SciPy Documentation][6])
* **NumPy** utilities: `ravel_multi_index` for consistent flattening convention if needed. ([NumPy][7])

Everything is CPU-trivial at ARC sizes.

---

## File & API (fixed)

**File:** `arc_cloth/model/potential.py`

```python
from __future__ import annotations
from typing import TypedDict, List, Dict, Any, Optional
import cvxpy as cp
import numpy as np
import scipy.sparse as sp

class ConvexProgram(TypedDict):
    X: cp.Variable                # (H*, W*, C)
    objective: cp.Expression      # scalar D(X)
    constraints: List[cp.Constraint]
    __meta__: Dict[str, Any]      # receipts: dcp_ok, term weights, etc.

def build_potential_cvxpy(inv: Dict[str, Any], H: int, W: int, C: int,
                          A_gamma: Optional[sp.csr_matrix] = None
                         ) -> ConvexProgram:
    """
    Build the single convex objective D(X) and constraints Γ for test size (H,W).
    Uses only DCP-valid atoms. Returns (X, objective, constraints, __meta__).
    """
```

---

## Decision variable & simplex constraints

* Declare (X\in\mathbb{R}^{H\times W\times C}) with

  ```python
  X = cp.Variable((H, W, C), nonneg=True)      # X >= 0
  constraints = [cp.sum(X, axis=2) == 1]       # per-pixel simplex
  ```

  (Nonnegativity + per-pixel sum-to-one are linear; DCP-valid. Sum is an affine atom. ([Cvxpy][2]))

* If Γ (from WO-07) is provided as CSR with shape ([M, H\cdot W\cdot C]), enforce
  [
  A,\mathrm{vec}(X)=0.
  ]
  In code:

  ```python
  if A_gamma is not None and A_gamma.shape[1] == H*W*C:
      X_vec = cp.reshape(X, (H*W*C, 1), order='C')    # keep C-order consistent
      constraints += [A_gamma @ X_vec == 0]
  ```

  (`reshape` is an affine atom; DCP-valid. We explicitly set C-order to match our vec convention; CVXPY reshape is column-major by default, hence the explicit order parameter. ([Cvxpy][4]))

---

## Compose (D) from v1 terms (all DCP-valid)

Weights default to 1.0; keep them in `__meta__` for receipts.

### 1) Color histogram / area preservation

* From WO-03: target per-color totals (\hat n_c).
* D term (L1 or L2; pick one and stay consistent):

  ```python
  totals = cp.sum(cp.sum(X, axis=1), axis=0)     # shape (C,)
  D_hist = cp.norm1(totals - n_hat)              # or cp.sum_squares(...)
  ```

  `sum`, `norm1`, `sum_squares` are documented atoms; DCP-valid. ([Cvxpy][2])

### 2) Horizontal/vertical periodicity

* From WO-04: periods (p) / (q) if stable.
* Horizontal:

  ```python
  if inv.get("period_h") is not None:
      p = int(inv["period_h"])
      diffs = []
      for j in range(W - p):
          diffs.append(cp.norm1(X[:, j, :] - X[:, j+p, :]))
      D_tile_h = cp.sum(diffs)
  ```
* Vertical similar with rows. L1 of affine differences is convex (DCP). ([Cvxpy][2])

### 3) Mirrors (midline) & concats

* From WO-05 patch: `mirror_h` means even (W) and (X[:, :W//2,:] == fliplr(X[:, W//2:,:])`.

  ```python
  if inv.get("mirror_h") and W % 2 == 0:
      left  = X[:, :W//2, :]
      right = X[:, W//2:, :]
      D_mir_h = cp.norm1(left - right[:, ::-1, :])   # exact equality if weight→∞; penalty in v1
  ```
* `mirror_v` similar with rows `[::-1]`.
* Concats:

  ```python
  if "h" in inv.get("concat_axes", []) and W % 2 == 0:
      D_concat_h = cp.norm1(X[:, :W//2, :] - X[:, W//2:, :])
  if "v" in inv.get("concat_axes", []) and H % 2 == 0:
      D_concat_v = cp.norm1(X[:H//2, :, :] - X[H//2:, :, :])
  ```

### 4) Block substitution (k×k)

* From WO-06: codebook `{in_patch_bytes -> out_patch_bytes}` and size `k`.
* In CVXPY we don’t need to reconstruct with mixture weights in v1; instead, encode **consistency ties** implied by the dictionary on the test grid:

  * If block dictionary is bijective and the test input (Π-normalized) provides a block grid, create an **affine copy** of the input’s block assignment and penalize deviation from the corresponding output prototype. In L1:

    ```python
    # For each aligned kxk block position r, we have a target prototype P_r (C-encoded one-hot planes)
    # Build D_block = sum_r norm1(X[block_r] - P_r)
    ```

  All `norm1` + affine extraction are DCP-valid. (We keep it simple; if a block position is out of dictionary coverage, skip in v1 and record coverage in receipts.)

### 5) Optional TV (straight line / border regularizer)

* CVXPY provides `total_variation`:

  ```python
  # TV on the per-color sum or on selected channels/bands when WO-05 indicates lines
  Y = cp.sum(X, axis=2)          # collapse colors to 2D intensity proxy
  D_tv = cp.tv(Y)                # documented atom
  ```

  (TV is convex; atom is documented in CVXPY. ([Cvxpy][3]))

### Total objective

* Sum all active terms with nonnegative weights:

  ```python
  objective = w_hist*D_hist + w_th*D_tile_h + w_tv*D_tv + ...  # only include defined terms
  prob = cp.Problem(cp.Minimize(objective), constraints)
  ```

---

## Receipts (first-class)

* `dcp_ok`: construct `prob` and call `prob.is_dcp()`. Must be True. (CVXPY DCP checker.) ([Cvxpy][1])
* `solver_default`: record `"CLARABEL"` or `"OSQP"` as the default; both ship with CVXPY. (ECOS is being deprecated as default; prefer CLARABEL/OSQP.) ([Cvxpy][5])
* `term_weights`: which terms and weights included.
* `gamma_rows`: if Γ provided, record `A_gamma.shape[0]`.
* **Train reproduction check (lightweight):**

  * Build the **same** objective expression on a **Constant** tensor from a train output (converted to one-hot (Y)), and compute `objective.value` (no solve). Expect ≈ 0 (or as low as penalty form allows) for that train pair. This shows the formulation matches the evidence without needing a full solve.

---

## Runner changes

* In `run_task.py`, add `"--check-D"` probe:

  * load → canonicalize → invariants → Γ → `build_potential_cvxpy(...)`
  * print receipts: `dcp_ok`, `term_weights`, `gamma_rows`
  * for each train pair, evaluate D on the ground-truth (Y) (as Constant) and print `D_train_value` (expect ≈ 0).
* In `scripts/run_arc.py`, add `--check-D` to emit a CSV with:
  `task_path, dcp_ok, gamma_rows, terms, D_train_mean, D_train_max`.

Reviewer rule: **100% of tasks must pass receipts** (no exceptions). If a task has no active invariants (rare), `objective` is still defined (e.g., 0) and DCP holds.

---

## Acceptance criteria

* **DCP-valid** (`prob.is_dcp()` True). ([Cvxpy][1])
* **Atoms only** from CVXPY docs (sum, norm1, sum_squares, reshape, total_variation). ([Cvxpy][2])
* **Γ integration** enforces `A @ vec(X) == 0` if provided (SciPy CSR). ([SciPy Documentation][6])
* **Train reproduction**: `objective.value` on each train output’s one-hot ≈ 0 (within penalty tolerance).
* **Deterministic**: same invariants → identical expression tree (log term list & weights).
* **Corpus-wide receipts**: runner shows `dcp_ok=True` for 100% tasks, no exceptions.

---

## Minimal code skeleton (Claude fills bodies; uses only cited APIs)

```python
import cvxpy as cp
import numpy as np
import scipy.sparse as sp

def build_potential_cvxpy(inv, H, W, C, A_gamma=None):
    X = cp.Variable((H, W, C), nonneg=True)
    constraints = [cp.sum(X, axis=2) == 1]
    if A_gamma is not None and A_gamma.shape[1] == H*W*C:
        X_vec = cp.reshape(X, (H*W*C, 1), order='C')     # explicit C-order
        constraints += [A_gamma @ X_vec == 0]

    terms = []
    weights = {}

    # 1) color histogram
    if "color_counts" in inv and inv["color_counts"]:
        n_hat = np.asarray(inv["color_counts"], dtype=float)
        totals = cp.sum(cp.sum(X, axis=1), axis=0)       # (C,)
        D_hist = cp.norm1(totals - n_hat)                # L1
        terms.append(D_hist); weights["hist"] = 1.0

    # 2) tiling
    if inv.get("period_h") is not None:
        p = int(inv["period_h"]); diffs = []
        for j in range(W - p):
            diffs.append(cp.norm1(X[:, j, :] - X[:, j+p, :]))
        terms.append(cp.sum(diffs)); weights["tile_h"] = 1.0
    if inv.get("period_v") is not None:
        q = int(inv["period_v"]); diffs = []
        for i in range(H - q):
            diffs.append(cp.norm1(X[i, :, :] - X[i+q, :, :]))
        terms.append(cp.sum(diffs)); weights["tile_v"] = 1.0

    # 3) mirrors & concats (midline)
    if inv.get("mirror_h") and W % 2 == 0:
        left, right = X[:, :W//2, :], X[:, W//2:, :]
        terms.append(cp.norm1(left - right[:, ::-1, :])); weights["mir_h"] = 1.0
    if inv.get("mirror_v") and H % 2 == 0:
        top, bot = X[:H//2, :, :], X[H//2:, :, :]
        terms.append(cp.norm1(top - bot[::-1, :, :])); weights["mir_v"] = 1.0
    if "h" in inv.get("concat_axes", []) and W % 2 == 0:
        terms.append(cp.norm1(X[:, :W//2, :] - X[:, W//2:, :])); weights["cat_h"] = 1.0
    if "v" in inv.get("concat_axes", []) and H % 2 == 0:
        terms.append(cp.norm1(X[:H//2, :, :] - X[H//2:, :, :])); weights["cat_v"] = 1.0

    # 4) block substitution (v1: penalty to closest prototype where covered) — optional; skip if none

    # 5) optional TV
    if inv.get("use_tv"):
        Y = cp.sum(X, axis=2)
        terms.append(cp.tv(Y)); weights["tv"] = 0.1      # conservative

    objective = cp.sum(terms) if terms else 0
    prob = cp.Problem(cp.Minimize(objective), constraints)

    meta = {
        "dcp_ok": bool(prob.is_dcp()),                   # DCP check
        "gamma_rows": int(A_gamma.shape[0]) if A_gamma is not None else 0,
        "term_weights": weights,
        "solver_default": "CLARABEL/OSQP/SCS"
    }
    return {"X": X, "objective": objective, "constraints": constraints, "__meta__": meta}
```

**Docs used:** CVXPY DCP & atoms/tutorials (sum, norm1, tv, reshape), solver list, SciPy sparse COO→CSR, NumPy ravel semantics. ([Cvxpy][1])

---

[1]: https://www.cvxpy.org/tutorial/dcp/index.html?utm_source=chatgpt.com "Disciplined Convex Programming -"
[2]: https://www.cvxpy.org/tutorial/functions/index.html?utm_source=chatgpt.com "Atomic Functions -"
[3]: https://www.cvxpy.org/_modules/cvxpy/atoms/total_variation.html?utm_source=chatgpt.com "cvxpy.atoms.total_variation -"
[4]: https://www.cvxpy.org/version/1.5/_modules/cvxpy/atoms/affine/reshape.html?utm_source=chatgpt.com "cvxpy.atoms.affine.reshape — CVXPY 1.5 documentation"
[5]: https://www.cvxpy.org/tutorial/solvers/index.html?utm_source=chatgpt.com "Solver Features -"
[6]: https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.html?utm_source=chatgpt.com "coo_matrix — SciPy v1.16.2 Manual"
[7]: https://numpy.org/doc/2.1/reference/generated/numpy.ravel_multi_index.html?utm_source=chatgpt.com "numpy.ravel_multi_index — NumPy v2.1 Manual"
