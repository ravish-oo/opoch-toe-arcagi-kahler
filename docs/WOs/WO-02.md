# WO-02 — Canonicalizer (Π idempotence)

## Purpose

Make every ARC task **presentation-invariant** before any modeling: remove pose and label minting by mapping each grid to a **single canonical representative** under the D4 symmetries of the square (rotations 0/90/180/270 and reflections) and a deterministic palette order. ARC tasks are JSON files with `"train"` and `"test"` pairs; grids are small integer matrices (colors 0–9). ([GitHub][1])

**Anchor docs to read before coding:**

* `docs/anchors/00-vision-universe.md` (§1–3: A0/Π, two moves, “negation first”)
* `docs/anchors/01-arc-on-the-cloth.md` (§1–2, §6–7: ARC format; free D4; snap rule)
* `docs/anchors/02-impl-contracts.md` (§3.1: canonicalization API & invariants)

This WO implements **Π**: “labels and pose do not change content,” so they are normalized away. D4 is the right symmetry group here (order 8; rotations + reflections). ([Wikipedia][2])

---

## Scope (v1)

* For **every** grid in `train[*].input`, `train[*].output`, and `test[0].input`:

  1. Apply **pose canonicalization** over all 8 D4 transforms; choose the **lexicographically minimal byte string** as the canonical pose.
  2. Apply **deterministic palette remap** to contiguous `[0..C-1]` by **first appearance order** scanning row-major.
* Emit the **same canonicalization** for inputs and outputs **consistently** across the task (pose choice is independent per grid; the palette renumbering is global per task).
* No resizing, no cropping, no heuristics. ARC grids are small integer matrices; we only change representation, not content. ([Kaggle][3])

**Out of scope:** invariants, interfaces, solving; any attempt to “recognize” a rule. Those WOs come later and must consume Π-normalized data.

---

## Libraries (pin to avoid reinvention)

* **NumPy** (`numpy`) for array transforms (rot90, flip).
* **Standard library only** otherwise (`typing`, `dataclasses`, `hashlib` for hashing).

No image libs, no external geometry libs. D4 transforms are direct on integer arrays.

---

## Public API (exact)

File: `arc_cloth/io/canonicalize.py`

```python
from __future__ import annotations
from typing import TypedDict, List, Tuple, Dict, Any
import numpy as np

Grid = List[List[int]]

class CanonicalTask(TypedDict):
    train: List[Dict[str, Grid]]
    test:  List[Dict[str, Grid]]
    __meta__: Dict[str, Any]   # receipts & bookkeeping

def canonicalize_task(task: Dict[str, Any]) -> CanonicalTask:
    """
    Apply Π to all grids in the task:
      1) D4 pose canonicalization (lexicographic min of bytes among the 8 transforms)
      2) Deterministic palette remap to contiguous [0..C-1] by first-appearance order
    Returns a deep-copied, canonicalized task with __meta__ receipts.

    Determinism requirements:
      - Same input -> same output 1:1
      - canonicalize_task(canonicalize_task(task)) == canonicalize_task(task)  (Π idempotence)
      - D4 transforms of original task all map to the *same* canonical task (orbit collapse)
    """
```

---

## Exact mechanics

### 1) D4 pose canonicalization (free isometries)

Implement the 8 transforms:

* Rotations: `R0` (identity), `R90`, `R180`, `R270`
* Reflections: `Fh` (horizontal), `Fv` (vertical)
* And the two **reflected rotations**: `R90∘Fh`, `R270∘Fh` (or equivalently generate all with `{rot90, flip}`)

Use NumPy primitives:

* `np.rot90(A, k)` for rotations
* `np.flip(A, axis)` for reflections

For each transform `T`, compute **byte key**:

```python
key_T = A_T.tobytes()   # A_T is np.ndarray dtype=np.uint8 (or int8) after palette remap candidate
```

Pick the transform with **minimal** `key_T` under Python’s lex order. This makes pose choice canonical and cheap.

**Why D4:** Square-grid symmetries are the order-8 dihedral group; rotations and reflections generate it. ([Wikipedia][2])

### 2) Palette remap (labels are free)

After pose selection **for that grid**, remap colors to `[0..C-1]` by scanning row-major and assigning the next integer upon first seeing a new color (per-task **global** order). This preserves relative identity across all grids in the task (train + test). ARC uses digits 0–9; remapping is label-only and Π-legal. ([GitHub][1])

**Order:**
Compute the global palette order **once per task** from the **union** of colors over all canonicalized grids (inputs & outputs), using first appearance order from a deterministic grid listing: `train[*].input`, `train[*].output`, then `test[0].input`, each in dataset order, rows then cols.

### 3) Idempotence & orbit collapse

* **Idempotence:** running canonicalize twice must be a no-op (Π²=Π).
* **Orbit collapse:** if you pre-transform the original task by any D4 element (on every grid), canonicalizing either version must yield **bit-identical** results. This ensures we truly quotient by free isometries (A0).

(ARC format and intent: grids of ints; JSON pairs train/test; these are presentation details we must erase before modeling.) ([GitHub][1])

---

## Receipts to emit (first-class)

Attach to the returned object in `__meta__`:

* `pi_idempotent: bool` — True if `canon(canon(task))==canon(task)` (deep compare)
* `orbit_collapse_ok: bool` — True if for all 8 D4 ops applied to the original task, canonicalization yields the **same hash** as the canonical task
* `chosen_pose: Dict[str, str]` — per grid, which of the 8 ops was selected (`"R0"|"R90"|...`)
* `palette_map: Dict[int,int]` — original color → remapped index
* `shape_summary: List[Tuple[int,int]]` — `(H,W)` for each grid (train inputs/outputs, test input)
* `format_ok: bool` — passthrough from loader (WO-01)

Hash recommendation: SHA-256 of a stable JSON dump of the canonical task (grids only), or `hashlib.sha256(np.stack(all_grids).tobytes()).hexdigest()`.

---

## Debugging playbook (implementer)

* **Wrong D4 ordering:** print all 8 keys in hex; confirm the chosen minimal matches expectation.
* **Palette mismatch across grids:** print first-appearance order and mapping; verify that remap is **global per task** (not per grid).
* **Non-idempotence:** dump before/after JSON; typical cause is nondeterministic palette order—fix iteration order to be explicit.
* **Orbit collapse fail:** ensure you apply the same D4 transform to **every** grid before canonicalizing; any mix will break equivalence.

---

## Runner changes (add now)

Extend `scripts/run_arc.py` with a **canon check mode**:

* `--mode canon` — load task (WO-01), canonicalize (WO-02), print receipts summary per file:

  * `pi_idempotent`, `orbit_collapse_ok`, `palette_map`, `chosen_pose` counts
* `--limit N` — process the first N tasks quickly
* Save the canonicalized task JSON under `--save out_dir` mirroring the directory tree for spot-checking.

ARC corpora on GitHub/Kaggle are organized as directories of JSON tasks; this runner lets the reviewer hit **all** tasks on CPU easily. ([GitHub][1])

---

## Reviewer/tester protocol

1. Read `00-vision-universe.md` (§1–3) and `01-arc-on-the-cloth.md` (§6: G_free D4).
2. Run:

```
python scripts/run_arc.py --root /path/to/arc --mode canon --save out_canon --limit 1000
```

3. Expect for **every** file:

   * `format_ok=True` (from WO-01)
   * `pi_idempotent=True`
   * `orbit_collapse_ok=True`
   * `palette_map` contiguous `[0..C-1]`
4. Any failure prints an actionable message. Typically: inconsistent palette scan order or a D4 transform misapplied.

**Note on task counts:** ARC/ARC-AGI JSONs follow the same `train`/`test` pair structure with small integer grids; some ARC-AGI-2 tasks include two test pairs, which we can gate with a clear “v1 supports single test” error until we choose to extend. ([GitHub][4])

---

## Acceptance criteria

* **A0/Π enforced:** `pi_idempotent=True`, `orbit_collapse_ok=True` on the entire corpus.
* **D4 exactness:** pose choice is always among the 8 true dihedral transforms; no other reindexing performed. ([Wikipedia][2])
* **Label neutrality:** palette remap is deterministic and contiguous.
* **Determinism:** same input task → bit-identical canonical output; stable hash present.
* **Runner harness:** `--mode canon` runs end-to-end on CPU across all tasks and writes canonicalized JSONs.

---

[1]: https://github.com/fchollet/ARC-AGI?utm_source=chatgpt.com "fchollet/ARC-AGI: The Abstraction and Reasoning Corpus"
[2]: https://en.wikipedia.org/wiki/Dihedral_group?utm_source=chatgpt.com "Dihedral group"
[3]: https://www.kaggle.com/competitions/abstraction-and-reasoning-challenge?utm_source=chatgpt.com "Abstraction and Reasoning Challenge"
[4]: https://github.com/arcprize/ARC-AGI-2?utm_source=chatgpt.com "arcprize/ARC-AGI-2"
